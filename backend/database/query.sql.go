// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const attachDbInfo = `-- name: AttachDbInfo :one
INSERT INTO GameDbInfo(
    igdb_id,
    metacritic_score,
    steam_id,
    game_info
) VALUES ($1, $2, $3, $4) RETURNING game_info, igdb_id, metacritic_score, steam_id
`

type AttachDbInfoParams struct {
	IgdbID          string
	MetacriticScore int32
	SteamID         string
	GameInfo        int32
}

func (q *Queries) AttachDbInfo(ctx context.Context, arg AttachDbInfoParams) (Gamedbinfo, error) {
	row := q.db.QueryRow(ctx, attachDbInfo,
		arg.IgdbID,
		arg.MetacriticScore,
		arg.SteamID,
		arg.GameInfo,
	)
	var i Gamedbinfo
	err := row.Scan(
		&i.GameInfo,
		&i.IgdbID,
		&i.MetacriticScore,
		&i.SteamID,
	)
	return i, err
}

const attachState = `-- name: AttachState :one

INSERT INTO GameState(
    game_info,
    game_list,
    user_rating,
    gametime_min,
    list_order
) VALUES ($1, $2, $3, $4, nextval('GameListOrder')) RETURNING game_info, game_list, user_rating, gametime_min, list_order, custom_status, last_played
`

type AttachStateParams struct {
	GameInfo    int32
	GameList    pgtype.Int4
	UserRating  int32
	GametimeMin int32
}

// --------------------------------
// Game State
// --------------------------------
func (q *Queries) AttachState(ctx context.Context, arg AttachStateParams) (Gamestate, error) {
	row := q.db.QueryRow(ctx, attachState,
		arg.GameInfo,
		arg.GameList,
		arg.UserRating,
		arg.GametimeMin,
	)
	var i Gamestate
	err := row.Scan(
		&i.GameInfo,
		&i.GameList,
		&i.UserRating,
		&i.GametimeMin,
		&i.ListOrder,
		&i.CustomStatus,
		&i.LastPlayed,
	)
	return i, err
}

const createGame = `-- name: CreateGame :one

INSERT INTO GameInfo(
    name,
    description,
    genres,
    artwork_url,
    release_date
) VALUES ($1, $2, $3, $4, $5) RETURNING id, name, description, genres, artwork_url, release_date
`

type CreateGameParams struct {
	Name        string
	Description string
	Genres      []string
	ArtworkUrl  pgtype.Text
	ReleaseDate pgtype.Date
}

// --------------------------------
// Game Info
// --------------------------------
func (q *Queries) CreateGame(ctx context.Context, arg CreateGameParams) (Gameinfo, error) {
	row := q.db.QueryRow(ctx, createGame,
		arg.Name,
		arg.Description,
		arg.Genres,
		arg.ArtworkUrl,
		arg.ReleaseDate,
	)
	var i Gameinfo
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Genres,
		&i.ArtworkUrl,
		&i.ReleaseDate,
	)
	return i, err
}

const createGameList = `-- name: CreateGameList :one

INSERT INTO GameList(
    name
) VALUES ($1) RETURNING id, name
`

// --------------------------------
// Game State
// --------------------------------
func (q *Queries) CreateGameList(ctx context.Context, name string) (Gamelist, error) {
	row := q.db.QueryRow(ctx, createGameList, name)
	var i Gamelist
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const deleteGame = `-- name: DeleteGame :exec
DELETE FROM GameInfo WHERE id = $1
`

func (q *Queries) DeleteGame(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteGame, id)
	return err
}

const deleteGameList = `-- name: DeleteGameList :exec
WITH res AS (
    DELETE FROM GameList WHERE id = $1 RETURNING id AS list_id
)
UPDATE GameState SET game_list = NULL
WHERE game_list = (SELECT list_id FROM res)
`

func (q *Queries) DeleteGameList(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteGameList, id)
	return err
}

const detachDbInfo = `-- name: DetachDbInfo :exec
DELETE FROM GameDbInfo
WHERE game_info = $1
`

func (q *Queries) DetachDbInfo(ctx context.Context, gameInfo int32) error {
	_, err := q.db.Exec(ctx, detachDbInfo, gameInfo)
	return err
}

const detachState = `-- name: DetachState :exec
DELETE FROM GameState
WHERE game_info = $1
`

func (q *Queries) DetachState(ctx context.Context, gameInfo int32) error {
	_, err := q.db.Exec(ctx, detachState, gameInfo)
	return err
}

const getBacklogGames = `-- name: GetBacklogGames :many
SELECT
    G.id,
    G.name,
    G.description,
    G.genres,
    G.artwork_url,
    G.release_date,
    DB.igdb_id,
    DB.metacritic_score,
    DB.steam_id,
    ST.game_list,
    ST.user_rating,
    ST.gametime_min,
    ST.list_order,
    ST.custom_status,
    ST.last_played
FROM GameInfo G
JOIN GameState ST ON ST.game_info = G.id
LEFT JOIN GameDbInfo DB ON DB.game_info = G.id
WHERE ST.game_list IS NULL
ORDER BY ST.list_order
`

type GetBacklogGamesRow struct {
	ID              int32
	Name            string
	Description     string
	Genres          []string
	ArtworkUrl      pgtype.Text
	ReleaseDate     pgtype.Date
	IgdbID          pgtype.Text
	MetacriticScore pgtype.Int4
	SteamID         pgtype.Text
	GameList        pgtype.Int4
	UserRating      int32
	GametimeMin     int32
	ListOrder       int32
	CustomStatus    string
	LastPlayed      pgtype.Date
}

func (q *Queries) GetBacklogGames(ctx context.Context) ([]GetBacklogGamesRow, error) {
	rows, err := q.db.Query(ctx, getBacklogGames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBacklogGamesRow
	for rows.Next() {
		var i GetBacklogGamesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Genres,
			&i.ArtworkUrl,
			&i.ReleaseDate,
			&i.IgdbID,
			&i.MetacriticScore,
			&i.SteamID,
			&i.GameList,
			&i.UserRating,
			&i.GametimeMin,
			&i.ListOrder,
			&i.CustomStatus,
			&i.LastPlayed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGame = `-- name: GetGame :one
SELECT
    G.id,
    G.name,
    G.description,
    G.genres,
    G.artwork_url,
    G.release_date,
    DB.igdb_id,
    DB.metacritic_score,
    DB.steam_id,
    ST.game_list,
    ST.user_rating,
    ST.gametime_min,
    ST.list_order,
    ST.custom_status,
    ST.last_played
FROM GameInfo G
LEFT JOIN GameDbInfo DB ON DB.game_info = G.id
LEFT JOIN GameState ST ON ST.game_info = G.id
WHERE G.id = $1
`

type GetGameRow struct {
	ID              int32
	Name            string
	Description     string
	Genres          []string
	ArtworkUrl      pgtype.Text
	ReleaseDate     pgtype.Date
	IgdbID          pgtype.Text
	MetacriticScore pgtype.Int4
	SteamID         pgtype.Text
	GameList        pgtype.Int4
	UserRating      pgtype.Int4
	GametimeMin     pgtype.Int4
	ListOrder       pgtype.Int4
	CustomStatus    pgtype.Text
	LastPlayed      pgtype.Date
}

func (q *Queries) GetGame(ctx context.Context, id int32) (GetGameRow, error) {
	row := q.db.QueryRow(ctx, getGame, id)
	var i GetGameRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Genres,
		&i.ArtworkUrl,
		&i.ReleaseDate,
		&i.IgdbID,
		&i.MetacriticScore,
		&i.SteamID,
		&i.GameList,
		&i.UserRating,
		&i.GametimeMin,
		&i.ListOrder,
		&i.CustomStatus,
		&i.LastPlayed,
	)
	return i, err
}

const getGameList = `-- name: GetGameList :one
SELECT id, name FROM GameList
WHERE id = $1
`

func (q *Queries) GetGameList(ctx context.Context, id int32) (Gamelist, error) {
	row := q.db.QueryRow(ctx, getGameList, id)
	var i Gamelist
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getGameListFrontGame = `-- name: GetGameListFrontGame :one
SELECT
    G.id,
    G.name,
    G.description,
    G.genres,
    G.artwork_url,
    G.release_date,
    DB.igdb_id,
    DB.metacritic_score,
    DB.steam_id,
    ST.game_list,
    ST.user_rating,
    ST.gametime_min,
    ST.list_order,
    ST.custom_status,
    ST.last_played
FROM GameInfo G
JOIN GameState ST ON ST.game_info = G.id
LEFT JOIN GameDbInfo DB ON DB.game_info = G.id
WHERE ST.game_list = $1
ORDER BY ST.list_order
`

type GetGameListFrontGameRow struct {
	ID              int32
	Name            string
	Description     string
	Genres          []string
	ArtworkUrl      pgtype.Text
	ReleaseDate     pgtype.Date
	IgdbID          pgtype.Text
	MetacriticScore pgtype.Int4
	SteamID         pgtype.Text
	GameList        pgtype.Int4
	UserRating      int32
	GametimeMin     int32
	ListOrder       int32
	CustomStatus    string
	LastPlayed      pgtype.Date
}

func (q *Queries) GetGameListFrontGame(ctx context.Context, gameList pgtype.Int4) (GetGameListFrontGameRow, error) {
	row := q.db.QueryRow(ctx, getGameListFrontGame, gameList)
	var i GetGameListFrontGameRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Genres,
		&i.ArtworkUrl,
		&i.ReleaseDate,
		&i.IgdbID,
		&i.MetacriticScore,
		&i.SteamID,
		&i.GameList,
		&i.UserRating,
		&i.GametimeMin,
		&i.ListOrder,
		&i.CustomStatus,
		&i.LastPlayed,
	)
	return i, err
}

const getGameListGames = `-- name: GetGameListGames :many
SELECT
    G.id,
    G.name,
    G.description,
    G.genres,
    G.artwork_url,
    G.release_date,
    DB.igdb_id,
    DB.metacritic_score,
    DB.steam_id,
    ST.game_list,
    ST.user_rating,
    ST.gametime_min,
    ST.list_order,
    ST.custom_status,
    ST.last_played
FROM GameInfo G
JOIN GameState ST ON ST.game_info = G.id
LEFT JOIN GameDbInfo DB ON DB.game_info = G.id
WHERE ST.game_list = $1
ORDER BY ST.list_order
`

type GetGameListGamesRow struct {
	ID              int32
	Name            string
	Description     string
	Genres          []string
	ArtworkUrl      pgtype.Text
	ReleaseDate     pgtype.Date
	IgdbID          pgtype.Text
	MetacriticScore pgtype.Int4
	SteamID         pgtype.Text
	GameList        pgtype.Int4
	UserRating      int32
	GametimeMin     int32
	ListOrder       int32
	CustomStatus    string
	LastPlayed      pgtype.Date
}

func (q *Queries) GetGameListGames(ctx context.Context, gameList pgtype.Int4) ([]GetGameListGamesRow, error) {
	rows, err := q.db.Query(ctx, getGameListGames, gameList)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGameListGamesRow
	for rows.Next() {
		var i GetGameListGamesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Genres,
			&i.ArtworkUrl,
			&i.ReleaseDate,
			&i.IgdbID,
			&i.MetacriticScore,
			&i.SteamID,
			&i.GameList,
			&i.UserRating,
			&i.GametimeMin,
			&i.ListOrder,
			&i.CustomStatus,
			&i.LastPlayed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGameLists = `-- name: GetGameLists :many
SELECT id, name FROM GameList
`

func (q *Queries) GetGameLists(ctx context.Context) ([]Gamelist, error) {
	rows, err := q.db.Query(ctx, getGameLists)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Gamelist
	for rows.Next() {
		var i Gamelist
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGameState = `-- name: GetGameState :one
SELECT game_info, game_list, user_rating, gametime_min, list_order, custom_status, last_played FROM GameState
WHERE game_info = $1
`

func (q *Queries) GetGameState(ctx context.Context, gameInfo int32) (Gamestate, error) {
	row := q.db.QueryRow(ctx, getGameState, gameInfo)
	var i Gamestate
	err := row.Scan(
		&i.GameInfo,
		&i.GameList,
		&i.UserRating,
		&i.GametimeMin,
		&i.ListOrder,
		&i.CustomStatus,
		&i.LastPlayed,
	)
	return i, err
}

const getGames = `-- name: GetGames :many
SELECT
    G.id,
    G.name,
    G.description,
    G.genres,
    G.artwork_url,
    G.release_date,
    DB.igdb_id,
    DB.metacritic_score,
    DB.steam_id,
    ST.game_list,
    ST.user_rating,
    ST.gametime_min,
    ST.list_order,
    ST.custom_status,
    ST.last_played
FROM GameInfo G
LEFT JOIN GameDbInfo DB ON DB.game_info = G.id
LEFT JOIN GameState ST ON ST.game_info = G.id
`

type GetGamesRow struct {
	ID              int32
	Name            string
	Description     string
	Genres          []string
	ArtworkUrl      pgtype.Text
	ReleaseDate     pgtype.Date
	IgdbID          pgtype.Text
	MetacriticScore pgtype.Int4
	SteamID         pgtype.Text
	GameList        pgtype.Int4
	UserRating      pgtype.Int4
	GametimeMin     pgtype.Int4
	ListOrder       pgtype.Int4
	CustomStatus    pgtype.Text
	LastPlayed      pgtype.Date
}

func (q *Queries) GetGames(ctx context.Context) ([]GetGamesRow, error) {
	rows, err := q.db.Query(ctx, getGames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGamesRow
	for rows.Next() {
		var i GetGamesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Genres,
			&i.ArtworkUrl,
			&i.ReleaseDate,
			&i.IgdbID,
			&i.MetacriticScore,
			&i.SteamID,
			&i.GameList,
			&i.UserRating,
			&i.GametimeMin,
			&i.ListOrder,
			&i.CustomStatus,
			&i.LastPlayed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setList = `-- name: SetList :exec
UPDATE GameState
SET game_list = $2
WHERE game_info = $1
`

type SetListParams struct {
	GameInfo int32
	GameList pgtype.Int4
}

func (q *Queries) SetList(ctx context.Context, arg SetListParams) error {
	_, err := q.db.Exec(ctx, setList, arg.GameInfo, arg.GameList)
	return err
}

const updateGame = `-- name: UpdateGame :one
UPDATE GameInfo
SET name = $2,
    description = $3,
    genres = $4,
    artwork_url = $5,
    release_date = $6
WHERE id = $1
RETURNING id, name, description, genres, artwork_url, release_date
`

type UpdateGameParams struct {
	ID          int32
	Name        string
	Description string
	Genres      []string
	ArtworkUrl  pgtype.Text
	ReleaseDate pgtype.Date
}

func (q *Queries) UpdateGame(ctx context.Context, arg UpdateGameParams) (Gameinfo, error) {
	row := q.db.QueryRow(ctx, updateGame,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Genres,
		arg.ArtworkUrl,
		arg.ReleaseDate,
	)
	var i Gameinfo
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Genres,
		&i.ArtworkUrl,
		&i.ReleaseDate,
	)
	return i, err
}

const updateGameList = `-- name: UpdateGameList :one
UPDATE GameList SET name = $2
WHERE id = $1
RETURNING id, name
`

type UpdateGameListParams struct {
	ID   int32
	Name string
}

func (q *Queries) UpdateGameList(ctx context.Context, arg UpdateGameListParams) (Gamelist, error) {
	row := q.db.QueryRow(ctx, updateGameList, arg.ID, arg.Name)
	var i Gamelist
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}
